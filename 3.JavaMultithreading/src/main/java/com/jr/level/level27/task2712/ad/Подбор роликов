
Что имеем:
    Хранилище доступных роликов
    Из каждого ролика можно получить:
        Имя
        Продолжительность
        Стоимость показа

    Предполагается что хранилище не отсортировано

Условия:
    1 Метод должен быть рекурсивный
    2 В наборе ролик должен быть показан не более одного раза
    3 Время показа не должно превышать время ожидания
    4 Если есть наборы с одинаковой суммой:
        а) берем с большим сумарным временем
        Если время одинаковое
        б) берем с меньшим количеством роликов
    5 Количество показов больше нуля

===========================================
    После подбора:
        Первичная сортировка
            В порядке уменшения стоимости показа в копейках
        Вторичная сортировка
            Увеличение стоимости показа одной секунды
            ролика в формате тысячных долей
            пример 0,222 копейки  = 222 тысячных долей
===========================================
    После каждого показа вызвать у ролика
        revalidate()


ИДЕИ по решению
    Подумаем:
        1 Сортировка хранилища в условии не предусмотренна
        2 Говорится о создания всех возможных сочетаний
        3 Нужно получить набор списков элементы которых соответствуют
            следующим критериям:
                Сумма времени < времени заказа
                1 элемент встречается 1 раз

        Как организовать рекурсию?
            Рекурсия должна вернуть 1 список
            Значит наполнение списков происходит внутри рекурсии

            Рекурсия строится на базе математической индукции
            Значит если нечто подходит для еденицы
            и подходит для n-1 то подойдет и для n

        ======================================================
        Предидущая версия так и не заработала
        подумаем снова.
        Нужно получть все возможные сочетания элементов без повторений.
        Похожую задачу я уже решал с числами Авогадро.
        Получение всех сочетаний элементов похоже на бинарное число.
        Количество вариантов = 2^N элементов. При этом ни одно из них не будет
        повторять предыдущее.

        Сегодня немало повозившись мне удалось обнаружить некоторые закономерности.
        Представим некое множество и выполним перебор
        всех сочетаний следующим образом:
        Множество:
        1234 5
        Сочетания без повторений:
        1,                       2,              3,     4      |5   уровень 1   одноцифровые
        12,13,14|15              23,24|25        34|35  |45         уровень 2   двухцифровые
        123,124|125,134,135,145  234|235,245     |345               уровень 3   трехцифровые
        ===========
        1234,1235                2345                               уровень 4   четырехцифровые
        1245
        1345
        12345                                                       уровень 5   пятицифровой

        Рекурсивный вызов в цикле -> вызов(start,end-1)
        1234   234   34   4
        123    23    3
        12     2
        1
==========================================================

        execution (start, deep, string, digits)
            for(i=start+deep; i < digits.length; i++)   //для всех значений начиная с текущей глубины
                tmp =new (string + digits[i])           //постройка после получения
                write(tmp)                              //вернуть последовательность
                execution(start,i+1,tmp, digits)
            end
         end

==========================================================









